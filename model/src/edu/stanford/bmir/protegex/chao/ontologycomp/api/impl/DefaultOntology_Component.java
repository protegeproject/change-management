package edu.stanford.bmir.protegex.chao.ontologycomp.api.impl;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;

import edu.stanford.bmir.protegex.chao.annotation.api.Annotation;
import edu.stanford.bmir.protegex.chao.annotation.api.impl.DefaultAnnotatableThing;
import edu.stanford.bmir.protegex.chao.annotation.api.impl.DefaultAnnotation;
import edu.stanford.bmir.protegex.chao.change.api.Change;
import edu.stanford.bmir.protegex.chao.change.api.ChangeFactory;
import edu.stanford.bmir.protegex.chao.change.api.Created_Change;
import edu.stanford.bmir.protegex.chao.change.api.Deleted_Change;
import edu.stanford.bmir.protegex.chao.change.api.Name_Changed;
import edu.stanford.bmir.protegex.chao.change.api.impl.DefaultChange;
import edu.stanford.bmir.protegex.chao.ontologycomp.api.OntologyComponentFactory;
import edu.stanford.bmir.protegex.chao.ontologycomp.api.Ontology_Component;
import edu.stanford.bmir.protegex.chao.ontologycomp.api.InternalStatus;
import edu.stanford.bmir.protegex.chao.ontologycomp.api.User;
import edu.stanford.bmir.protegex.chao.util.ChangeDateComparator;
import edu.stanford.smi.protege.code.generator.wrapping.OntologyJavaMappingUtil;
import edu.stanford.smi.protege.model.Cls;
import edu.stanford.smi.protege.model.Instance;
import edu.stanford.smi.protege.model.Slot;
import edu.stanford.smi.protege.util.Log;

/**
 * Generated by Protege (http://protege.stanford.edu).
 * Source Class: Ontology_Component
 *
 * @version generated on Mon Aug 18 21:08:59 GMT-08:00 2008
 */
public class DefaultOntology_Component extends DefaultAnnotatableThing
implements Ontology_Component {

	public DefaultOntology_Component(Instance instance) {
		super(instance);
	}


	public DefaultOntology_Component() {
	}

	// Slot associatedAnnotations

	@Override
	public Collection<Annotation> getAssociatedAnnotations() {
		Collection protegeValues = getWrappedProtegeInstance().getOwnSlotValues(getAssociatedAnnotationsSlot());
		Collection<Annotation> values = new ArrayList<Annotation>();
		Cls cls = getKnowledgeBase().getCls("Annotation");
		for (Object object : protegeValues) {
			if (object instanceof Instance && ((Instance)object).hasType(cls)) {
				values.add(new DefaultAnnotation((Instance)object));
			}
		}
		return values;
	}


	@Override
	public Slot getAssociatedAnnotationsSlot() {
		final String name = "associatedAnnotations";
		return getKnowledgeBase().getSlot(name);
	}


	@Override
	public boolean hasAssociatedAnnotations() {
		return hasSlotValues(getAssociatedAnnotationsSlot());
	}


	@Override
	public void addAssociatedAnnotations(Annotation newAssociatedAnnotations) {
		addSlotValue(getAssociatedAnnotationsSlot(), newAssociatedAnnotations);
	}


	@Override
	public void removeAssociatedAnnotations(Annotation oldAssociatedAnnotations) {
		removeSlotValue(getAssociatedAnnotationsSlot(), oldAssociatedAnnotations);
	}


	@Override
	public void setAssociatedAnnotations(Collection<? extends Annotation> newAssociatedAnnotations) {
		setSlotValues(getAssociatedAnnotationsSlot(), newAssociatedAnnotations);
	}

	// Slot changes

	public Collection<Change> getChanges() {
		Collection protegeValues = getWrappedProtegeInstance().getOwnSlotValues(getChangesSlot());
		Collection<Change> values = new ArrayList<Change>();
		Cls cls = getKnowledgeBase().getCls("Change");
		for (Object object : protegeValues) {
			if (object instanceof Instance && ((Instance)object).hasType(cls)) {
				values.add(new DefaultChange((Instance)object));
			}
		}
		return values;
	}


	public Slot getChangesSlot() {
		final String name = "changes";
		return getKnowledgeBase().getSlot(name);
	}


	public boolean hasChanges() {
		return hasSlotValues(getChangesSlot());
	}


	public void addChanges(Change newChanges) {
		addSlotValue(getChangesSlot(), newChanges);
	}


	public void removeChanges(Change oldChanges) {
		removeSlotValue(getChangesSlot(), oldChanges);
	}


	public void setChanges(Collection<? extends Change> newChanges) {
		setSlotValues(getChangesSlot(), newChanges);
	}

	// Slot currentName

	public String getCurrentName() {
		return (String) getWrappedProtegeInstance().getOwnSlotValue(getCurrentNameSlot());
	}


	public Slot getCurrentNameSlot() {
		final String name = "currentName";
		return getKnowledgeBase().getSlot(name);
	}


	public boolean hasCurrentName() {
		return hasSlotValues(getCurrentNameSlot());
	}


	public void setCurrentName(String newCurrentName) {
		setSlotValue(getCurrentNameSlot(), newCurrentName);
	}
	
    // Slot watchedBy

    public Collection<User> getWatchedBy() {
        Collection protegeValues = getWrappedProtegeInstance().getOwnSlotValues(getWatchedBySlot());
        Collection<User> values = new ArrayList<User>();
        Cls cls = getKnowledgeBase().getCls("User");
        for (Object object : protegeValues) {
            if (object instanceof Instance && ((Instance)object).hasType(cls)) {
                values.add(new DefaultUser((Instance)object));
            }
        }
        return values;
    }


    public Slot getWatchedBySlot() {
        final String name = "watchedBy";
        return getKnowledgeBase().getSlot(name);
    }


    public boolean hasWatchedBy() {
        return hasSlotValues(getWatchedBySlot());
    }


    public void addWatchedBy(User newWatchedBy) {
        addSlotValue(getWatchedBySlot(), newWatchedBy);
    }


    public void removeWatchedBy(User oldWatchedBy) {
        removeSlotValue(getWatchedBySlot(), oldWatchedBy);
    }


    public void setWatchedBy(Collection<? extends User> newWatchedBy) {
        setSlotValues(getWatchedBySlot(), newWatchedBy);
    }

	// __Code above is automatically generated. Do not change

	private final static String ANONYMOUS_NAME_PREFIX = "@";

	private String initialName = null;

	public InternalStatus getInternalStatus() {
		Collection<Change> allChanges = getChanges();
		List<Change> nameChanges = getSortedNameChanges();
		if (allChanges == null || allChanges.isEmpty()) {
			return InternalStatus.UNCHANGED;
		}
		else {
			boolean created = false;
			boolean deleted = false;
			// Can't assume that the deleted change is last
			//     - there might be a composite change following
			for (Change change : nameChanges) {
				if (change.canAs(Created_Change.class)) {
					created = true;
				}
				if (change.canAs(Deleted_Change.class)) {
					deleted = true;
					break;
				}
			}
			if (created && deleted) {
				return InternalStatus.CREATED_AND_DELETED;
			}
			else if (created) {
				return InternalStatus.CREATED;
			}
			else if (deleted) {
				return InternalStatus.DELETED;
			}
			else {
				return InternalStatus.CHANGED;
			}
		}

	}


	public String getInitialName() {
		if (initialName != null) {
			return initialName;
		}
		List<Change> nameChanges = getSortedNameChanges();
		if (nameChanges.isEmpty()) {
			return getCurrentName();
		}
		if (nameChanges.get(0).canAs(Created_Change.class)) {
			return null;
		}
		Collections.reverse(nameChanges);
		String name = getCurrentName();
		for (Change i : nameChanges) {
			if (i.canAs(Deleted_Change.class)) {
				Deleted_Change change = i.as(Deleted_Change.class);
				name = change.getDeletionName();
			}
			else if (i.canAs(Name_Changed.class)) {
				Name_Changed change = i.as(Name_Changed.class);
				name = change.getOldName();
			}
			else if (i.canAs(Created_Change.class)) {
				Created_Change change = i.as(Created_Change.class);
				return null;
			}
		}
		initialName = name;
		return name;
	}


	public List<Change> getSortedNameChanges() {
		Collection<Change> changes = getChanges();
		List<Change> nameChanges = new ArrayList<Change>();
		for (Change i : changes) {
			if (OntologyJavaMappingUtil.canAs(i, Deleted_Change.class) ||
					OntologyJavaMappingUtil.canAs(i, Name_Changed.class) ||
					OntologyJavaMappingUtil.canAs(i, Created_Change.class)) {
				nameChanges.add(i);
			}
		}
		if (!nameChanges.isEmpty()) {
			Collections.sort(nameChanges, new ChangeDateComparator(getKnowledgeBase()));
		}
		return nameChanges;
	}

	public List<Change> getSortedChanges() {
		List<Change> changes = new ArrayList<Change>(getChanges());
		Collections.sort(changes, new ChangeDateComparator(getKnowledgeBase()));
		return changes;
	}

	public List<Change> getSortedTopLevelChanges(){
		List<Change> topLevelChanges = new ArrayList<Change>();
		List<Change> changes = new ArrayList<Change>(getSortedChanges());

		for (Change i : changes) {
			Change change = i;

			Change compositeChange = change.getPartOfCompositeChange();

			if (compositeChange == null) {
				topLevelChanges.add(change);
			}
		}

		return topLevelChanges;
	}

	public String mostRecentName() {
		String name = getCurrentName();
		if (name != null) { return name; }
		List<Change> changes = getSortedChanges();
		Collections.reverse(changes);
		ChangeFactory factory = new ChangeFactory(getKnowledgeBase());
		for (Change i : changes) { //TODO: TT not working!!! Deletes don't show up..
			if (OntologyJavaMappingUtil.canAs(i, Deleted_Change.class)) {
				Deleted_Change change = OntologyJavaMappingUtil.as(i, Deleted_Change.class);
				name = change.getDeletionName();
				if (!name.contains("<<missing frame name")) {
					return name;  // TODO -- TR -- FIX ME
				}
			}
		}
		return null;
	}


	public boolean isAnonymous() {
		String name = mostRecentName();
		if (name != null) {
			return name.startsWith(ANONYMOUS_NAME_PREFIX);
		}
		Log.getLogger().warning("Could not determine anonymous status of " + this);
		return true;
	}

	public  String getComponentType() {
		//work around
		Cls type = getWrappedProtegeInstance().getDirectType();
		OntologyComponentFactory factory = new OntologyComponentFactory(type.getKnowledgeBase());

		if (type.equals(factory.getOntology_ClassClass())) {
			return "Class";
		} else if (type.equals(factory.getOntology_PropertyClass())) {
			return "Property";
		} else if (type.equals(factory.getOntology_IndividualClass())) {
			return "Individual";
		}
		return "Unknown type";
	}

	@Override
	public String toString() {
		switch (getInternalStatus()) {
		case CHANGED:
			return "Modified Object: " + getCurrentName();
		case CREATED:
			return "New Object: " + getCurrentName();
		case DELETED:
			return "Deleted Object: " + getInitialName();
		case CREATED_AND_DELETED:
			return "Created and Deleted Object";
		case UNCHANGED:
			return "Unchanged Object: " + getCurrentName();
		default:
			throw new RuntimeException("Developer missed a case");
		}
	}
}
